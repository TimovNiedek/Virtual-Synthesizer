//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Disregard above statement

using UnityEngine;
using System.Collections;
using Leap;

/* *
 * Custom RigidFinger class for handling collisions and adding FingerTips
 * 
 * Authors:
 * Daniel Roeven
 * Timo van Niedek
 * */

public class PianoFinger : RigidFinger
{
	public bool isTouchingNote = false;
	public int noteTouched = -1;

	public GameObject fingerTip;

	// The scale and tipScale are used to scale the coordinates of the fingertips
	// to make them appear at the position of the leap motion fingertips.
	// These values are estimated.
	private Vector3 scale = new Vector3(1.0f, 1.05f, 0.6f);
	private Vector3 tipScale = new Vector3 (0.25f, 0.25f, 0.25f);

	private BoxCollider collider;
	private Rigidbody tipRigidBody;
	private FingerTip tipScript;
	private Vector3 touchLocation;
	private bool isTouchingWhiteNote = false;
	private Note playingNote;

	void Start() {
		for (int i = 0; i < bones.Length; ++i) {
			if (bones[i] != null){
				bones[i].rigidbody.maxAngularVelocity = Mathf.Infinity;

				// Remove the colliders of all phalanges except for the fingertip
				if (i != 3)
				{
					bones[i].rigidbody.collider.enabled = false;
				}
			}
		}

		// Add sphere at fingertip
		Frame frame = controller_.GetFrame ();
		Vector spawnLocationLeap = leapToWorld(this.finger_.TipPosition, frame.InteractionBox);
		Vector3 spawnLocation = spawnLocationLeap.ToUnity ();
		spawnLocation.Scale (scale);

		// This sphere is copied for the FingerTip
		GameObject sphere = GameObject.CreatePrimitive (PrimitiveType.Sphere);

		fingerTip = (GameObject)Instantiate(sphere, spawnLocation, Quaternion.identity);
		fingerTip.transform.localScale = tipScale;
		fingerTip.name = "FingerTip";
		AddComponents ();
		tipScript.setParentFinger (this);

		// Destroy the original sphere
		GameObject.Destroy (sphere);
	}

	// Add the components to the fingertip
	void AddComponents(){
		collider = fingerTip.AddComponent ("BoxCollider") as BoxCollider;
		collider.isTrigger = true;
		tipScript = (FingerTip) fingerTip.AddComponent ("FingerTip");
		tipRigidBody = fingerTip.AddComponent<Rigidbody>();
		tipRigidBody.useGravity = false;
		tipRigidBody.isKinematic = true;
		tipRigidBody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
	}

	void FixedUpdate(){
		Frame frame = controller_.GetFrame ();
		Vector locationLeap = leapToWorld(this.finger_.TipPosition, frame.InteractionBox);
		Vector3 location = locationLeap.ToUnity ();
		location.Scale (scale);

		// If the finger is touching a node, freeze its x and z coordinates
		if (isTouchingNote && touchLocation != Vector3.zero) {
			if (location.y > touchLocation.y){
				// If the y coordinate of the finger is higher than the original touch location,
				// stop freezing the finger
				setTouchingNote(false,false, null);
			} else {
				Vector3 newLocation = location;
				newLocation.x = touchLocation.x;
				newLocation.z = touchLocation.z;

				// Get the angle and Z position of the key that is currently played by this finger
				float keyAngle = playingNote.gameObject.transform.localEulerAngles.z;
				float keyZ = playingNote.gameObject.transform.position.z;

				// If the key is all the way down, perform trigonometry to set the y location of the fingertip
				if (playingNote != null && keyAngle >= 4.99f){
					float deltaZ = keyZ - touchLocation.z;
					const float tan = 0.0874f;
					float deltaY = tan * deltaZ;

					// The y location needs to be calculated using the height of the key
					if (isTouchingWhiteNote){
						newLocation.y = 2.1f - deltaY;
					} else {
						newLocation.y = 3f - deltaY;
					}
				}

				fingerTip.transform.position = newLocation;
			}
		} else if (!isTouchingNote) {
			// If the finger is not touching any key, set the location of the fingertip to
			// the position of the leap motion finger
			fingerTip.transform.position = location;
		}
	}

	// Convert leap motion coordinates to world coordinates
	Leap.Vector leapToWorld(Leap.Vector leapPoint, InteractionBox iBox){
		//leapPoint.z *= -1.0f;
		Leap.Vector normalized = iBox.NormalizePoint (leapPoint, false);
		normalized -= new Leap.Vector (0.5f, 0f, 0.5f);
		return normalized * 13.0f;
	}

	public void setTouchingNote(bool touching, bool isWhite, Note touchingNote){
		this.isTouchingNote = touching;
		this.isTouchingWhiteNote = isWhite;
		this.playingNote = touchingNote;
		if (touching) {
			touchLocation = fingerTip.transform.position;
		} else {
			touchLocation = Vector3.zero	;
		}
	}

	void OnDestroy() {
		Debug.Log ("OnDestroy: PianoFinger");
		Destroy (fingerTip);
	}

	public void Hoi(){
		Debug.Log ("Hoi: PianoFinger");
	}

}

